{$R-,S-,I-,D-,F-,V-,B-,N-,L+ }

unit gensubs;

interface

uses dos,MDosIO,gentypes;

function strr (n:integer):mstr;
function streal (r:real):mstr;
function strlong (l:double):mstr;
function valu (q:mstr):integer;
function realvalu (q:mstr):real;
function longvalu (q:mstr):double;
function ratio(x1,x2:double):integer;
function addrstr (p:pointer):sstr;
procedure parse3 (s:lstr; var a,b,c:word);
function packtime (var dt:datetime):double;
    { Replaces Turbo's procedural version }
function now:double;
function timestr (time:double):sstr;
function TimeStr_24 (Time:double):Sstr;
function timeval (q:sstr):double;
function timepart (time:double):double;
function datestr (time:double):sstr;
function tdatestr(Time:double):sstr;
function dateval (q:sstr):double;
function datepart (time:double):double;
function upstring (s:anystr):anystr;
function match (s1,s2:anystr):boolean;
function devicename (name:lstr):boolean;
function exist (n:lstr):boolean;
procedure appendfile (name:lstr; var q:text);
procedure addexitproc (p:pointer);
procedure doneexitproc;

implementation

const maxexitprocs=25;

var exitstack:array [1..maxexitprocs] of pointer;
    exitstackptr:integer;

type packedtimerec=record
       date,time:word
     end;

function strr (n:integer):mstr;
var q:mstr;
begin
  str (n,q);
  strr:=q
end;

function streal (r:real):mstr;
var q:mstr;
begin
  str (r:0:0,q);
  streal:=q
end;

function strlong (l:double):mstr;
var q:mstr;
begin
  str (l,q);
  strlong:=q
end;

function valu (q:mstr):integer;
var i,s,pu:integer;
    r:real;
begin
  While Q[Length(Q)]=#32 Do Q[Length(Q)]:=Pred(Q[Length(Q)]);
  valu:=0;
  if length(q)=0 then exit;
  if not (q[1] in ['0'..'9','-']) then exit;
  if length(q)>5 then exit;
  val (q,r,s);
  if s<>0 then exit;
  if (r<=32767.0) and (r>=-32767.0)
    then valu:=round(r)
end;

function realvalu (q:mstr):real;
var i,s,pu:integer;
    r:real;
begin
  realvalu:=0;
  i:=pos(':',Q);
  If i>0 then Q[i]:='.';
  if length(q)=0 then exit;
  if not (q[1] in ['0'..'9','-']) then exit;
  if length(q)>7 then exit;
  val (q,r,s);
  if s<>0 then exit;
  if (r<=99999999.999) and (r>=-99999999.999)
    then realvalu:=r
end;

function longvalu (q:mstr):double;
var i,s,pu:integer;
    r:double;
begin
  longvalu:=0;
  if length(q)=0 then exit;
  if not (q[1] in ['0'..'9','-']) then exit;
  if length(q)>11 then exit;
  val (q,r,s);
  if s<>0 then exit;
  if (r<=2147483647) and (r>=-2147483647)
    then longvalu:=r
end;

function ratio(x1,x2:double):integer;
var x3:integer;
    y1,y2,y3:real;
Begin
  if x1<1 then x1:=1;
  if x2<1 then x2:=1;
  y1:=int(x1);
  y2:=int(x2);
  y3:=y1/y2;
  y3:=y3*100;
  x3:=trunc(y3);
  ratio:=x3;
end;

function addrstr (p:pointer):sstr;

  function hexstr (n:integer):sstr;

    function hexbytestr (b:byte):sstr;
    const hexchars:array[0..15] of char='0123456789ABCDEF';
    begin
      hexbytestr:=hexchars[b shr 4]+hexchars[b and 15]
    end;

  begin
    hexstr:=hexbytestr (hi(n))+hexbytestr(lo(n))
  end;

begin
  addrstr:=hexstr(seg(p^))+':'+hexstr(ofs(p^))
end;

procedure parse3 (s:lstr; var a,b,c:word);
var p:integer;

  procedure parse1 (var n:word);
  var ns:lstr;
  begin
    ns[0]:=#0;
    while (p<=length(s)) and (s[p] in ['0'..'9']) do begin
      ns:=ns+s[p];
      p:=p+1
    end;
    if length(ns)=0
      then n:=0
      else n:=valu(ns);
    if p<length(s) then p:=p+1
  end;

begin
  p:=1;
  parse1 (a);
  parse1 (b);
  parse1 (c)
end;

function packtime (var dt:datetime):double;
var l:double;
begin
  dos.packtime (dt,l);
  packtime:=l
end;

function now:double;
var dt:datetime;
    t:word;
    l:double;
begin
  gettime (dt.hour,dt.min,dt.sec,t);
  getdate (dt.year,dt.month,dt.day,t);
  l:=packtime (dt);
  now:=l
end;

function timestr (time:double):sstr;
var h1:integer;
    ms:sstr;
    dt:datetime;
const ampmstr:array [false..true] of string[2]=('am','pm');
begin
  unpacktime (time,dt);
  h1:=dt.hour;
  if h1=0
    then h1:=12
    else if h1>12
      then h1:=h1-12;
  ms:=strr(dt.min);
  if dt.min<10 then ms:='0'+ms;
  timestr:=strr(h1)+':'+ms+' '+ampmstr[dt.hour>11]
end;

function TimeStr_24(Time:double):Sstr;
VAR DT:DateTime; h1:integer; m,ms:sstr;
Begin
  Unpacktime(time,dt); ms[0]:=Chr(0);
  h1:=dt.hour;
  If h1<10 then ms:='0'+Strr(H1) Else Ms:=Strr(h1);
  ms:=Ms+':';
  M:=Strr(Dt.Min);
  If Dt.Min<10 then M:='0'+M;
  TimeStr_24:=Ms+M;
End;

function datestr (time:double):sstr;
var dt:datetime;
begin
  unpacktime (time,dt);
{  datestr:=strr(dt.month)+'/'+strr(dt.day)+'/'+strr(dt.year) }
{  dont need to do this - et voila y2k -felonius 11-Jan 2022  }
   datestr:=strr(dt.month)+'/'+strr(dt.day)+'/'+strr(dt.year)
end;

Function TDateStr(time:double):Sstr;
Var Dt:DateTime; B,S:Sstr;
Begin
  Unpacktime(time,dt);
  B:=Strr(dt.month);
  If Valu(B)<10 then Begin
    B:='0'; B:=B+Strr(Dt.Month)
  End;
  S:=B;
  B:=strr(dt.day);
  If Valu(B)<10 then Begin
    B:='0'; B:=B+Strr(Dt.Day)
  End;
  S:=S+'/'+B;
{  B:=Strr(Dt.Year-1900); }
{  more y2k wheee  -felonius 11-Jan 2022 }
   B:=Strr(Dt.Year);
  S:=S+'/'+B;
  TDateStr:=S;
End;

function timepart (time:double):double;
begin
  timepart:=time and $0000ffff;
end;

function datepart (time:double):double;
begin
  datepart:=time and $ffff0000;
end;

procedure cleardatetime (var dt:datetime);
begin
  unpacktime (0,dt)
end;

function timeval (q:sstr):double;
var h1,t:word;
    k:char;
    dt:datetime;
begin
  cleardatetime (dt);
  parse3 (q,h1,dt.min,t);
  k:=upcase(q[length(q)-1]);
  if h1 in [1..11]
    then
      begin
        dt.hour:=h1;
        if k='P' then dt.hour:=dt.hour+12
      end
    else
      if k='P'
        then dt.hour:=12
        else dt.hour:=0;
  timeval := (dt.hour * 60) + (dt.min);
  { timeval:=timepart(packtime(dt)) }
end;

function dateval (q:sstr):double;
var dt:datetime;
begin
  cleardatetime (dt);
  parse3 (q,dt.month,dt.day,dt.year);
  if dt.year<100 then dt.year:=dt.year+1900;
  dateval:=datepart(packtime(dt))
end;

function upstring (s:anystr):anystr;
var cnt:integer;
begin
  for cnt:=1 to length(s) do s[cnt]:=upcase(s[cnt]);
  upstring:=s
end;

function match (s1,s2:anystr):boolean;
var cnt:integer;
begin
  match:=false;
  if length(s1)<>length(s2) then exit;
  for cnt:=1 to length(s1) do
    if upcase(s1[cnt])<>upcase(s2[cnt])
      then exit;
  match:=true
end;

function devicename (name:lstr):boolean;
var f:file;
    n:integer absolute f;
    r:registers;
begin
  devicename:=false;
  assign (f,name);
  reset (f);
  if ioresult<>0 then exit;
  r.bx:=n;
  r.ax:=$4400;
  intr ($21,r);
  devicename:=(r.dx and 128)=128;
  close (f)
end;

function exist (n:lstr):boolean;
{ var f:file;
    i:integer; }
begin

  Exist := Dos_Exists(N);
  {
  assign (f,n);
  reset (f);
  i:=ioresult;
  exist:=i=0;
  close (f);
  i:=ioresult
  }
end;

procedure appendfile (name:lstr; var q:text);
var n:integer;
    b:boolean;
    f:file of char;
begin
  close (q);
  n:=ioresult;
  assign (q,name);
  assign (f,name);
  reset (f);
  b:=(ioresult<>0) or (filesize(f)=0);
  close (f);
  n:=ioresult;
  if b
    then rewrite (q)
    else append (q)
end;

procedure addexitproc (p:pointer);
begin
  inc (exitstackptr);
  if exitstackptr>maxexitprocs then begin
    writeln ('Too many exit procedures');
    halt (255)
  end else begin
    exitstack[exitstackptr]:=exitproc;
    exitproc:=p
  end
end;

procedure doneexitproc;
begin
  exitproc:=exitstack[exitstackptr];
  dec (exitstackptr)
end;

begin
  exitstackptr:=0
end.
